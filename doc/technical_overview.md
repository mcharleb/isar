# 1 Introduction

Isar can be shortly described as a set of bitbake recipes that implement main build system logic. To simplify overall Isar understanding, this document is split into two main parts:
 - Isar logical components
 - Isar internal processes

# 2 Isar Logical Components

In this chapter the most important Isar components are considered in details. In this text component doesn't especially mean some self-contained single entity of something, it's just an attempt to split Isar internals by various criteria.

## 2.1 Bitbake and Recipes

All the processes in Isar are started by bitbake, so it manages general build executing process. Recipes in Isar can be split in two categories:

 - System recipes and classes: they are responsible for setting up Debian-like infrastructure, manages Debian tools execution for package building and installation, generation root file system images
 - User recipes: custom user applications, that should be buil–µ from sources

There are two types of dependencies in Isar:
 - Dependency between bitbake recipes
 - Dependencies in Debian filesystem

**NOTE:** Isar doesn't manage dependencies in Debian file systems. User can only list specific Debian dependencies in recipe, so they eventually will be passed to apt-get or multistrap. Dependency installation is managed by Debian tools.

## 2.2 Stamps

Each task managed by bitbake uses stamp to notify that it has been completed. Due to Isar supports various Debian distributions and parallel builds for multiple machines and architectures, the stamps for tasks use special suffixes that include:
 - Debian distro name
 - Architecture
 - Machine

Typical example, when Isar builds the following configurations:
 - Debian Jessie, amd64
 - Debian Jessie, i386
 - Debian Stretch, i386

In this case there will be 3 different buildchroots, so standard hello demo application should be processed 3 times for each environment. Three different sets of stamps should be used for correct bitbake operating.

## 2.3 Buildchroot

One of the key aspect of Debian philosophy claims the fact, that everything in Debian should be built within Debian environment. Moreover native compilation is more preferable than cross-compilation. To follow this rules, Isar introduces the new component - buildchroot. Bulidchroot is typical Debian filesystem that is created using standard Debian tools: multistrap, apt. The source of packages can be either official Debian repositories or custom repositories created by user.

Buildchroot lifecycle can be described as following:
 - Buildchroot has initial configuration file which is passed to multistrap tool. This configuration file is generated by bitbake recipe from patterns and values defined by user. Based on this configuration file, multistrap generates initial filesystem.
 - During building custom Debian package, list of its build dependencies is installed to buildchroot.
 - When package has been built, it's installed to current buildchroot to satisfy further packages build dependencies.

## 2.4 Target Root Filesystem

Target filesystem is quite similar to buildchroot. The only difference is that it doesn't have development packages installed.

Target filesystem lifecycle can be described as following:
 - Target filesystem has initial configuration file which is passed to multistrap tool. This configuration file is generated by bitbake recipe from patterns and values defined by user. Based on this configuration file, multistrap generates initial filesystem.
 - According to the list of custom packages in bitbake recipes, the initial filesystem will be populated by successfully built packages.

# 3 Isar Internal Processes

## 3.1 General Overview

Whole Isar build process can be split into the following steps:
 - Generation of initial buildchroots for each configuration (Debian distro, machine and architecture) requested by user.
 - Generation of initial target filesystems for each configuration.
 - Building custom packages.
 - Populate target filesystems.
 - Generate bootable images.

All these steps are described in details below.

## 3.2 Initial Buildchroot Generation

As mentioned above, initial buildchroot is generated using multistrap. The bitbake recipe which is responsible for buildchroot can be found here: `meta/recipes-devtools/buildchroot/buildchroot.bb`

This recipe implementes `do_build` task which performs the following:
1. Generates multistrap config from template: `meta/recipes-devtools/buildchroot/files/multistrap.conf.in`
2. Install pre/post scripts for multistrap: `meta/recipes-devtools/buildchroot/files/configscript.sh` and `meta/recipes-devtools/buildchroot/files/setup.sh`
3. Run multistrap
4. Install script for building custom Debian packages: `meta/recipes-devtools/buildchroot/files/build.sh`

The single stamp is created for each user buildchroot configuration.

## 3.3 Initial Target Filesystem Generation

Initial target filesystem generation process is very similar to buildchroot creating, the difference is only in initial packages list.

Target image recipes are the part of Isar core. There is a sample of typical Isar image that can be customized according to the user requirements: `meta-isar/recipes-core/images/isar-image-base.bb`
Like for buildchroot, the multistrap configuration files for image can be found here: `meta-isar/recipes-core/images/files`, and it implements `do_build` task.

## 3.4 Building Custom Packages

Isar provides possibility to build Debian packages from sources. This features works with Debian-like source packages, i.e. the source code tree should contain debian folder. The build process is implemented in `meta/classes/dpkg.bbclass` and consists from the following steps:
1. Task `do_fetch`: fetch source code from external link
2. Task `do_unpack`: unpack source code to `${BUILDCHROOT_DIR}/home/build/${PN}`
3. Task `do_build`: switch to buildchroot using chroot command and run `build.sh` script. The `build.sh` script performs the following:
   1. Go to `/home/build/${PN}`
   2. Get list of dependencies from debian/control and install them using apt.
   3. Run dpkg-buildpackage
4. Task `do_install`: install successfully built packages `${BUILDCHROOT_DIR}/home/build/${PN}/*.deb` to deploy directory `${DEPLOY_DIR_DEB}`

## 3.5 Populate Target Filesystem

Each target image can be extended by custom packages listed in IMAGE_INSTALL variable. Task `do_populate` performs the following:
1. Parse IMAGE_INSTALL variable
2. Find respective packages in `${DEPLOY_DIR_DEB}`
3. Copy them to deb folder in dedicated target filesystem
4. Execute dpkg command in chroot for all the copied packages

## 3.6 Generate Bootable Image

This process contains the following steps:
1. Task `do_ext4_image`: target filesystem is packed to extfs image
2. wic tool generates bootable image for dedicated platform
